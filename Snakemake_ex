

# rule files:
#     input:
#         fasta = "/mnt/raid/ga/data/gisaid/gisaid1230/sequences_micron.fasta",
#         fasta_wo_N = "/mnt/raid/ga/data/gisaid/gisaid1230/sequences_micron_woN.fasta",
#         meta =  "/mnt/raid/ga/data/gisaid/gisaid1230/meta.tsv",
#         reference =  "/mnt/raid/ga/data/gisaid/gisaid1230/sequences_micron_lt_woN.fasta",
#         meta_data = config["data_meta"]
#     params:
#         target_amount = 12000,
#         output_dir = "lineages",
#         lineage = "Omicron"

outdir = config["output_dir"]
lineage = config["lineage"]
lineage = lineage.split()


rule tree:
    input:
        expand( outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned.fasta",lineage = lineage), 
        expand( outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned_veryfast.nwk",lineage = lineage), 
        expand(outdir + "/output/{lineage}_timetree_traits.json",lineage = lineage),
        expand(outdir+"/output/{lineage}_clusters.txt",lineage = lineage),

rule target:
    input:
        #expand(outdir + "/output/{lineage}_timetree.nwk",lineage = [lineage]), 
        #expand(outdir+"/tmp/minimap2_match_chosen_aligned_{lineage}_veryfast_resolved_fixed_raxml.nwk",lineage = [lineage]) 
        #expand(outdir+"/tmp/{lineage}_initialtreeTrimmedRooted.nwk",lineage = [lineage]),
        #expand(outdir+"/output/{lineage}_clusters.txt",lineage = [lineage]),
        #expand(outdir+"/output/{lineage}_focused.nwk",lineage = [lineage]),
        expand(outdir+"/output/{lineage}_focused_wosiblings_collapsed1.nwk",lineage = lineage),
        expand(outdir+"/output/{lineage}_focused_wosiblings_collapsed1.json",lineage = lineage),
        expand(outdir+"/output/{lineage}_focused_collapsed2.nwk",lineage = lineage),
        expand(outdir+"/output/{lineage}_focused_collapsed2.json",lineage = lineage),
        expand(outdir + "/output/{lineage}_timetree_branch_lengths.json",lineage = lineage),
        expand(outdir + "/output/{lineage}_timetree_traits.json",lineage = [lineage]),

rule init_lineage:
    output:
        start_mark = outdir+"/lineage_{lineage}.txt"
    shell:
        """
        touch {output.start_mark}
        """

rule get_lineage_ids:
    input:
        start_mark = outdir+"/lineage_{lineage}.txt",
        pangolin = config["data_pangolin"],
        nextclade = config["data_nextclade"]
    output:
        lineage_ids = outdir+"/tmp/lineage_{lineage}.ids" 
    params:
        lineage="{lineage}"
    conda:
        "envs/r.yaml"
    script:
        "scripts/filterLineage.R"    
    
rule get_lineage_sequences:
    input:
        lineage_ids = outdir+"/tmp/lineage_{lineage}.ids",
        sequences = config["sequences"] 
    output:
        lineage_seqs = outdir+"/tmp/lineage_{lineage}.all.fasta"
    conda:
        "envs/analysis.yaml"
    shell:
        "seqkit grep -n -f {input.lineage_ids} -i {input.sequences} -o {output.lineage_seqs}"    
    

rule get_subset_ids:
    input:
        meta = config["data_meta"],
        lineage_ids = outdir+"/tmp/lineage_{lineage}.ids",
    params:
        subset_max = config["subset_amount_maximum"]
    output:
        lineage_seqs_lt = outdir+"/tmp/lineage_{lineage}_sub.ids.txt"
    conda:
        "envs/r.yaml"
    script:
        "scripts/get_subset.R"    
    


rule get_lineage_subset_sequences:
    input:
        lineage_seqs_sub_ids = outdir+"/tmp/lineage_{lineage}_sub.ids.txt",
        lineage_seqs = outdir+"/tmp/lineage_{lineage}.all.fasta"
    output:
        lineage_sub_seqs = outdir+"/tmp/lineage_{lineage}.sub.fasta"
    conda:
        "envs/analysis.yaml"
    shell:
        "seqkit grep -n -f {input.lineage_seqs_sub_ids} -i {input.lineage_seqs} -o {output.lineage_sub_seqs}"    

rule remove_n:
    input:
        raw = outdir + "/{stem}.fasta"
    output:
        raw_woN = outdir + "/{stem}_woN.fasta"
    conda:
        "envs/analysis.yaml"
    shell:
       " seqkit seq -g -G N -i {input} -o {output} "

rule find_closest:
    input:
        reference = outdir+"/tmp/lineage_{lineage}.sub_woN.fasta",
        fasta = outdir+"/tmp/lineage_{lineage}.all_woN.fasta"
    output:
        rez = outdir+"/tmp/minimap2_match_{lineage}.closest.txt"
    threads: 80
    conda:
        "envs/analysis.yaml"
    shell:
        """
        minimap2 -t {threads}  {input.reference} {input.fasta}  -o   {output} 
        """

rule sortminimap:
    input:
        nextclade = outdir+"/tmp/minimap2_match_{lineage}.closest.txt"
    output: 
        ids = outdir+"/tmp/minimap2_match_chosen_{lineage}.ids",
        ids_target = outdir+"/tmp/minimap2_match_chosen_{lineage}.ids_target",
        ids_additional = outdir+"/tmp/minimap2_match_chosen_{lineage}.ids_additional",
    conda:
        "envs/r.yaml"
    params:
        target_amount = config["target_amount"] 
    script:
        "scripts/minimap.R"    


rule extract_top_seqyences:
    input:
       ids = outdir+"/tmp/minimap2_match_chosen_{lineage}.ids",
       fasta = outdir+"/tmp/lineage_{lineage}.all.fasta"
    output:
       fasta_ini = outdir+"/tmp/minimap2_match_chosen_ini{lineage}_not_ordered.fa",
    threads: 80
    conda:
        "envs/analysis.yaml"
    shell:
        "seqkit grep -n -j {threads} -f {input.ids} -o {output} -w 0 -i {input.fasta} "


rule get_top_sequences:
    input:
       ids = outdir+"/tmp/minimap2_match_chosen_{lineage}.ids",
       fasta_ini = outdir+"/tmp/minimap2_match_chosen_ini{lineage}_not_ordered.fa",
    output:
       fasta_final = outdir+"/tmp/minimap2_match_chosen_{lineage,\D{1,3}\d?(\.\d+){1,3}}.fasta",
    conda:
        "envs/analysis.yaml"
    shell:
       "  rm -f {input.fasta_ini}.fai ; seqkit faidx {input.fasta_ini} --infile-list {input.ids} -w 0 -o {output} "


rule align:
    message:
        """
        Aligning sequences to {input.reference}
          - filling gaps with N
        """
    input:
        sequences = outdir+"/tmp/minimap2_match_chosen_{lineage}.fasta",
        reference = config["reference"]
    output:
        alignment = outdir+"/tmp/minimap2_match_chosen_{lineage,\D{1,3}\d?(\.\d+){1,3}}_aligned.fasta",
        #alignment = outdir+"/tmp/minimap2_match_chosen_{lineage,\D{1,3}?\.\d+\.\d+\.\d+}_aligned.fasta",
    conda:
        "envs/analysis.yaml"
    threads: 20
    shell:
        """
        augur align \
            --sequences {input.sequences} \
            --reference-sequence {input.reference} \
            --output {output.alignment} \
            --fill-gaps \
            --remove-reference \
            --nthreads {threads}
        """


rule inital_tree:
    message:
        """
        Running very fast tree
        """
    input:
        alignment = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned.fasta",
    output:
        alignment = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned_veryfast.nwk",
    conda:
        "envs/analysis.yaml"
    threads: 20
    shell:
        """
        cat {input} |  VeryFastTree -nosupport  -gamma -nt -gtr -out {output}  -double-precision  -threads {threads}
      """
        # export OMP_NUM_THREADS={threads} ; cat {input} |  FastTree -nosupport  -gamma -nt -gtr -out {output}  
        #cat {input} |  VeryFastTree -nosupport  -gamma -nt -gtr -out {output}  -threads {threads}



rule resolve_tree:
    message:
        """
        Resilving multifurcatings
        """
    input:
        tree = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned_veryfast.nwk",
    output:
        tree = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned_veryfast_resolved.nwk",
    conda:
        "envs/analysis.yaml"
    threads: 1
    shell:
        """
        gotree resolve -i {input} -o {output}
        """

rule fix_brancges:
    message:
        """
        Recalculate branch length
        """
    input:
        tree = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned_veryfast_resolved.nwk",
        alignment = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned.fasta",
    output:
        tree = outdir+"/output/{lineage}_initialtree.nwk",
    conda:
        "envs/raxml.yaml"
    params:
        prefix = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned_veryfast_resolved_fixed_raxml",
        output = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned_veryfast_resolved_fixed_raxml.raxml.bestTree"
    threads: 20
    shell:
        """
        raxml-ng --blopt nr_safe  --redo --precision 12--redo --msa {input.alignment} --model GTR+FO+I+R4 --evaluate --tree {input.tree} --prefix {params.prefix} --threads auto
        mv {params.output} {output}
        """

rule get_time_tree:
    """
    Refining tree
        - estimate timetree
        - use {params.coalescent} coalescent timescale
        - estimate {params.date_inference} node dates
        - filter tips more than {params.clock_filter_iqd} IQDs from clock expectation
    """
    input:
        tree = outdir+"/output/{lineage}_initialtree.nwk",
        alignment = outdir+"/tmp/minimap2_match_chosen_{lineage}_aligned.fasta",
        metadata = config["data_meta"],
    output:
        tree = outdir+"/output/{lineage}_timetree.nwk",
        node_data = outdir + "/output/{lineage}_timetree_branch_lengths.json"
    params:
        coalescent = "opt",
        date_inference = "marginal",
        clock_filter_iqd = 4
    conda:
        "envs/analysis.yaml"
    shell:
        """
        augur refine \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --metadata {input.metadata} \
            --output-tree {output.tree} \
            --output-node-data {output.node_data} \
            --timetree \
            --coalescent {params.coalescent} \
            --date-confidence  --root best \
            --date-inference {params.date_inference} \
            --clock-filter-iqd {params.clock_filter_iqd} \
        """


rule get_outgroup:
    input:
        timetree = outdir+"/output/{lineage}_timetree.nwk",
    output:
        timetreeroot = outdir+"/tmp/{lineage}_timetree.root",
    shell:
        """
        ./scripts/extract_outgroup_tree.jl -i {input} -o {output}
        """



rule get_matching_original_tree:
    input:
        tree = outdir+"/output/{lineage}_initialtree.nwk",
        timetree = outdir+"/output/{lineage}_timetree.nwk",
    output:
        treeajusted = outdir+"/tmp/{lineage}_initialtreeTrimmed.nwk",
    conda:
        "envs/analysis.yaml"
    shell:
        """
        gotree prune -i {input.tree} -c {input.timetree} -o {output.treeajusted}
        """


rule get_reroted_matching_original_tree:
    input:
        treeajusted = outdir+"/tmp/{lineage}_initialtreeTrimmed.nwk",
        timetreeroot = outdir+"/tmp/{lineage}_timetree.root",
    output:
        treeajusted = outdir+"/tmp/{lineage}_initialtreeTrimmedRooted.nwk",
    conda:
        "envs/analysis.yaml"
    shell:
        """
        gotree reroot outgroup -l {input.timetreeroot} -i {input.treeajusted} -o {output}
        """

rule split_tree:
    input:
        treeajusted = outdir+"/tmp/{lineage}_initialtreeTrimmedRooted.nwk",
    output:
        directory(outdir+"/tmp/{lineage}_initialtreeTrimmedRooted_splits"),
    params:
        maxn = config["maximum_amount_4_splits"],
    conda:
        "envs/analysis.yaml"
    shell:
        """
        ./scripts/split_tree.jl -i {input} -o {output}
        """



rule get_clustering:
    input:
        outdir+"/tmp/{lineage}_initialtreeTrimmedRooted_splits",
    output:
        outdir+"/output/{lineage}_clusters.txt",
    params:
        wd = outdir+"/tmp/{lineage}_initialtreeTrimmedRooted_splits"
    conda:
        "envs/phydelity.yaml"
    shell:
        """
        wd=` pwd `
        cd {params.wd}
        for l in tree*.nwk ; do
            stem=${{l/\.nwk/""}} 
            echo $stem
            nohup phydelity.py --k 2 --collapse_zero_branch_length -t  $l > pydelity_wd_$l.log &
        done
        wait
        for l in tree*.nwk ; do
            stem=${{l/\.nwk/""}} 
            clsf=cluster_phydelity_k2_sol0_"$stem".txt
            cat $clsf | grep -v "CLUSTER" | sed "s/^/cl"$stem"_/g" >> $wd"/"{output}
        done
        """


rule get_focused_with_siblings:
    input:
        treeajusted = outdir+"/output/{lineage}_timetree.nwk",
        lineage_seqs_sub_ids = outdir+"/tmp/lineage_{lineage}_sub.ids.txt",
    output:
        treefocused = outdir+"/output/{lineage}_focused.nwk",
    conda:
        "envs/analysis.yaml"
    shell:
        """
        ./scripts/focus_tree.jl -i {input.treeajusted} -l {input.lineage_seqs_sub_ids} -o {output} -s
        """

rule get_focused_wo_siblings:
    input:
        treeajusted = outdir+"/output/{lineage}_timetree.nwk",
        lineage_seqs_sub_ids = outdir+"/tmp/lineage_{lineage}_sub.ids.txt",
    output:
        treefocused = outdir+"/output/{lineage}_focused_wosiblings.nwk",
    conda:
        "envs/analysis.yaml"
    shell:
        """
        ./scripts/focus_tree.jl -i {input.treeajusted} -l {input.lineage_seqs_sub_ids} -o {output} 
        """

rule traits:
    message:
        """
        Inferring ancestral traits for {params.columns!s}
          - increase uncertainty of reconstruction by {params.sampling_bias_correction} to partially account for sampling bias
        """
    input:
        tree = outdir+"/output/{lineage}_timetree.nwk",
        metadata = config["data_meta"],
    output:
        node_data = outdir + "/output/{lineage}_timetree_traits.json"
    params:
        columns = "country",
        #columns = "region country",
        sampling_bias_correction = 3
    conda:
        "envs/analysis.yaml"
    shell:
        """
        augur traits \
            --tree {input.tree} \
            --metadata {input.metadata} \
            --output {output.node_data} \
            --columns {params.columns} \
            --confidence \
            --sampling-bias-correction {params.sampling_bias_correction}
        """

rule collapse_tree:
    input:
        node_data = outdir + "/output/{lineage}_timetree_traits.json",
        treefocused = outdir+"/output/{lineage}_focused_wosiblings.nwk",
    output:
        treefocusedcollapsed = outdir+"/output/{lineage}_focused_wosiblings_collapsed1.nwk",
        treefocusedcollapsed_data = outdir+"/output/{lineage}_focused_wosiblings_collapsed1.json",
    conda:
        "envs/analysis.yaml"
    shell:
        """
        ./scripts/collapse_tree.jl -j {input.node_data} -i {input.treefocused} -o {output.treefocusedcollapsed} -d {output.treefocusedcollapsed_data} 
        """

rule collapse_tree2:
    input:
        node_data = outdir + "/output/{lineage}_timetree_traits.json",
        treefocused = outdir+"/output/{lineage}_focused.nwk",
    output:
        treefocusedcollapsed = outdir+"/output/{lineage}_focused_collapsed2.nwk",
        treefocusedcollapsed_data = outdir+"/output/{lineage}_focused_collapsed2.json", 
    conda:
        "envs/analysis.yaml"
    shell:
        """
        ./scripts/collapse_tree.jl -j {input.node_data} -i {input.treefocused} -o {output.treefocusedcollapsed} -d {output.treefocusedcollapsed_data} 
        """


        #nohup phydelity.py --k 2 --collapse_zero_branch_length -t  $f > pydelity_wd_$f.log &  
